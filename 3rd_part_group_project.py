# -*- coding: utf-8 -*-
"""3rd part Group project

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HBch7KnigJmHhus2ySteujQ4nMV3QkoI
"""

import numpy as np
import matplotlib.pyplot as plt

#initialization
nx = 300
# ny = 1
nt = 1000
v_x0 = 0
v_y0 = 0# initial velocity
delta_x = 1
delta_y = 1  ## y
delta_t = 0.1
gamma = 1.4
U = np.zeros((nx, 4))
G = np.zeros((nx, 4)) ## G
F = np.zeros((nx, 4))
F_half = np.zeros((nx, 4))
G_half = np.zeros((nx, 4))
U_der = np.zeros((nx, 4))

# initialization of U
for i in range(nx):
    if i < nx / 2:
        rho_L = 1
        P_L = 0.8
        U[i, 0:4] = np.array([rho_L, rho_L*v_x0, rho_L*v_y0,P_L])
    else:
        rho_R = 0.1
        P_R = 0.1
        U[i, 0:4] = np.array([rho_R, rho_R*v_x0,rho_R*v_y0, P_R])

def find_f(U):      ## Find f_U and G_U
    v_x = U[:, 1] / U[:,  0]  ## v in x-direction
    v_y = U[:, 2] / U[:,  0]  ## v in y-direction
    P = (gamma-1)*U[:,0]*(U[:,3]/U[:,0]-0.5*(v_x**2+v_y**2))
    e = P/((gamma-1)*U[:,0])
    F[:,0] = U[:,1]
    F[:,1] = U[:,1]*v_x + P
    F[:,2] = U[:,1]*v_y
    F[:,3] = (U[:,0]*(e+0.5*(v_x**2+v_y**2))+P)*v_x
    # print(F)
    return F

def find_G(U):      ## Find f_U and G_U
    v_x = U[:, 1] / U[:,  0]  ## v in x-direction
    v_y = U[:, 2] / U[:,  0]  ## v in y-direction
    P = (gamma-1)*U[:,0]*(U[:,3]/U[:,0]-0.5*(v_x**2+v_y**2))
    e = P/((gamma-1)*U[:,0])
    G[:,0] = U[:,2]
    G[:,1] = U[:,1]*v_y
    G[:,2] = U[:,2]*v_y + P
    G[:,3] = (U[:,0]*(e+0.5*(v_x**2+v_y**2))+P)*v_y
    # print(F)
    return F

def find_f_half(U,F):
    v_x = U[:, 1] / U[:,  0]
    v_y = U[:, 2] / U[:,  0]
    P = (gamma-1)*U[:,0]*(U[:,3]/U[:,0]-0.5*(v_x**2+v_y**2))
    c_s = np.sqrt(P*gamma/U[:,0])
    lambda_p = np.sqrt(v_x**2+v_y**2) + c_s
    lambda_m = np.sqrt(v_x**2+v_y**2) - c_s
    # print(lambda_m[1,0]*U[1,0,1])
    alpha = np.zeros((nx,6)) #first three rows alpha plus, second three alpha minus
    for i in range(nx-1):
        for k in range(3):
            alpha[i,k] = max(0, lambda_p[i], lambda_p[i+1])
            alpha[i,k+3] = max(0, -lambda_m[i], -lambda_m[i+1])
    # print(alpha.max())
    F_half = (alpha[:nx-1,0:3]*F[:nx-1,:]+alpha[:nx-1,3:6]*F[1:,:]-alpha[:nx-1,0:3]*\
              alpha[:nx-1,3:6]*(U[1:,:]-U[:nx-1,:]))/(alpha[:nx-1,0:3]+alpha[:nx-1,3:6]) ## eq5
    return F_half

def find_G_half(U,F):
    v_x = U[:, 1] / U[:,  0]
    v_y = U[:, 2] / U[:,  0]
    P = (gamma-1)*U[:,0]*(U[:,3]/U[:,0]-0.5*(v_x**2+v_y**2))
    c_s = np.sqrt(P*gamma/U[:,0])
    lambda_p = np.sqrt(v_x**2+v_y**2)+ c_s
    lambda_m = np.sqrt(v_x**2+v_y**2) - c_s
    # print(lambda_m[1,0]*U[1,0,1])
    alpha = np.zeros((nx,6)) #first three rows alpha plus, second three alpha minus
    for i in range(nx-1):
        for k in range(3):
            alpha[i,k] = max(0, lambda_p[i], lambda_p[i+1])
            alpha[i,k+3] = max(0, -lambda_m[i], -lambda_m[i+1])
    # print(alpha.max())
    G_half = (alpha[:nx-1,0:3]*G[:nx-1,:]+alpha[:nx-1,3:6]*G[1:,:]-alpha[:nx-1,0:3]*\
              alpha[:nx-1,3:6]*(U[1:,:]-U[:nx-1,:]))/(alpha[:nx-1,0:3]+alpha[:nx-1,3:6])
    return G_half



def find_u_der(F_half, D_half, delta_x):
    U_der = -(F_half[1:,:]-F_half[:-1,:])/delta_x - (G_half[1:,:]-G_half[:-1,:])/delta_x
    U_der = np.append(U_der,[np.array([0,0,0,0])], axis=0) #4 coloums
    U_der = np.vstack([np.array([0,0,0,0]),U_der])
    # print(U_der)
    return U_der

def find_u(U, U_der,delta_t,ii):
    # print(U)
    # U_histor[i] = U[:nx-2,:,:]
    if ii % 50 == 0:
        plt.plot(range(nx), U[:,0])
    U[:,:]= U[:,:] + delta_t*U_der
    # print(U)
    return U

for i in range(nt):
    F = find_f(U)
    G = find_G(U)
    F_half = find_f_half(U,F)
    G_half = find_G_half(U,G)
    U_der = find_u_der(F_half,G_half)
    U = find_u(U,U_der,delta_t,i)

plt.show()